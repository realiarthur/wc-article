# Веб-компоненты в реальном проекте

Кастомные компоненты, поддерживаемые браузером из коробки и возможность расширять встроенные html-элементы - давно звучало как один из следующих шагов во фронтенд-разработке. Но при выборе технологий для реальных проектов всегда стоит вопрос "Будущее уже настало?"

О самой технологии веб-компонентов уже достаточно написано, и руки давно чесались попробовать ее на реальном проекте. Речь в статье пойдет об этом опыте (а не о технологии), о том с какими проблемами пришлось столкнуться, их решениях, и о том как многие концепции, к которым мы привыкли при работе с фреймворками, легко перекладываются на веб-компоненты. 


## Почему веб-компоненты? 
Проект был небольшим и требовательным к размеру бандла, основными ui-составляющими которого являлись формы. Кто-то скажет, что все можно было сделать нативным html+js, что было бы максимально лаконично. Но если говорить о поддержке и расширении проекта, даже учитывая трабования к размеру бандла, отказываться от всех преимуществ компонентной разработки было бы подобно прыжку в прошлое.

С другой стороны, можно было бы использовать [Svelte](https://github.com/sveltejs/svelte) или, например, [Preact](https://github.com/preactjs/preact). Но попробовать сделать все, оперируя нативными концепциями, было слишком заманчивой идеей. 


## Будущее уже настало? 
Большинство современных браузеров поддерживают веб-компоненты из коробки, включая мобильные. Для остальных есть [полифилы](https://www.npmjs.com/package/@webcomponents/webcomponentsjs). Примечательно то, что для полифилов есть умный [лоадер](https://www.npmjs.com/package/@webcomponents/webcomponentsjs#using-webcomponents-loaderjs) (~2kB), который не загружает полифил определенного функционала, если для него есть нативная поддержка браузером. Таким образом в современные браузеры ничего не загружается.

Полифилы заявляют поддержку вплоть до IE11 и ранних версий Edge. К счастью, мы не поддерживаем IE11 в наших проектах, в Edge действительно все работает (самая ранняя зарегистрированная нами версия пользователя - 13). !!!Проверить как в 13 работает!!!

> Небольшие ограничения по работе полифилов:
> - Полифильный тег ```<slot></slot>``` для IE11 & Edge не участвуют во вспытии событий
> - Этот набор полифилов не предоставляет функционал для расширения встроенных html-элементов. Об этом подробнее ниже  


## LitElement
"Как много boilerplate-кода для создания компонентов и реактивной работы с пропсами! Нужно ускорить процесс, и написать класс расширяющий HTMLElement, реализующий этот код" - такой была первая мысль, которая возникла при погружении в веб-компоненты. Писать ничего не пришлось - эту работу берет на себя класс [LitElement](https://lit-element.polymer-project.org/) (~7kb). А использующийся в нем [lit-html](https://lit-html.polymer-project.org/) (~3.5kB), предоставляет удобный и оптимизированный механизм рендеринга и упрощает привязку данных и подписку на события. 

Кроме того, LitElement расширяет стандартный жизненный цикл веб-компонентов удобными [дополнениями](https://lit-element.polymer-project.org/guide/lifecycle), делая его во многом схожим с жизненным циклом компонента React.

--- функциональный рендеринг и директивы в сравнении с useState

Кто-то скажет что LitElement - это еще одна зависимость, еще один фреймворк, и я спешу согласиться! Но я осознанно решился на эти 7 килобайт, потому что оперируя только нативным API, предполагающим бо́льшие трудозатраты на разработку, я рисковал сильно затянуть проект.
 
  
## Компоненты высшего порядка
lit-redux
- посмотреть реализацию react redux
- https://github.com/jmas/lit-redux
- написать о том что из замыкания использовать, чтобы все классы обернулись





репозиторий про исследование
смотреть историю коммитов sso-frontend и библиотек

Привычные концепции (жизненный цикл, hoc) 

lite-form: submit, blur 
(когда были slot, когда перестали быть, но использовал расширение html, почему отказался)

redux
css host
no shadowDom, css через vars
